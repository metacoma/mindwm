---
classes:
  - common
  - mindwm
  - vim
  - tmuxinator
  - bash.kapitan
  - tmuxinator
  - tmuxinator.kapitan
  - logstash
  - kapitan.bash.compile-fetch
  - kafka
  - vector
  - vector.tmux-bytestream-kafka
#  - vector.tmux-kafka
#  - vector.console-output
  - opensearch
  - vector.config
  - helm
  - vector.helm

parameters:

  target_name: vector


  bash:
    functions:
      # https://vector.dev/docs/setup/installation/package-managers/nix/
      # TODO(@metacoma) parametrize vector release name
      vector_upgrade: |
        local values_file=\${1:-${compiled_dir}/helm/aggregator.yaml}
        shift
        (
          cd ${kapitan_root}/files/helm-charts/vector
          helm upgrade vector --install -n ${vector_k8s_ns} . -f \${values_file} $*
        )
      vector_values: |
        (
          cd ${kapitan_root}/files/helm-charts/vector
          vim -R values.yaml
        )
      # TODO(@metacoma) parametrize vector release name
      vector_delete: |
        (
          cd ${kapitan_root}
          helm uninstall -n ${vector_k8s_ns} vector
        )

      vector_logs: |
        (
          kubectl -n vector logs -f statefulset.apps/vector
        )

  vector_aggregator_port: 31399



  helm:
    aggregator: &vector_aggregator
      image:
        repository: ${vector_image:repo}
        tag: ${vector_image:tag}
      serviceHeadless:
        enabled: false
      service:
        enabled: True
        type: "NodePort"
        ports:
          - name: aggregator
            protocol: TCP
            port: ${vector_aggregator_port}
            targetPort: ${vector_aggregator_port}
            nodePort: ${vector_aggregator_port}
      customConfig:
#
#
#                       ___  ___  _   _ _ __ ___ ___  ___
#                      / __|/ _ \| | | | '__/ __/ _ \/ __|
#                      \__ \ (_) | |_| | | | (_|  __/\__ \
#                      |___/\___/ \__,_|_|  \___\___||___/
#
#

        sources:
          tmux-pane-bytestream:
            type: vector
            address: 0.0.0.0:${vector_aggregator_port}
            version: "2"
            acknowledgements:
              enabled: false

          kafka-tmux-pane-io-context:
            type: kafka
            acknowledgements:
              enabled: false
            bootstrap_servers: "${kafka_cluster_name}-kafka-external-bootstrap.${kafka_k8s_namespace}:${kafka_port}"
            group_id: vector_kafka
            topics:
              - ${kafka_topic_tmux_io_context}

          kafka-tmux-pane-linestream:
            type: kafka
            acknowledgements:
              enabled: false
            bootstrap_servers: "${kafka_cluster_name}-kafka-external-bootstrap.${kafka_k8s_namespace}:${kafka_port}"
            group_id: vector_kafka
            topics:
              - ${kafka_topic_tmux_linestream}

#              _                        __
#             | |                      / _|
#             | |_ _ __ __ _ _ __  ___| |_ ___  _ __ _ __ ___  ___
#             | __| '__/ _` | '_ \/ __|  _/ _ \| '__| '_ ` _ \/ __|
#             | |_| | | (_| | | | \__ \ || (_) | |  | | | | | \__ \
#              \__|_|  \__,_|_| |_|___/_| \___/|_|  |_| |_| |_|___/
#
#

        transforms:
          kafka-io-context-to-elasticsearch:
            type: "remap"
            inputs:
              - kafka-tmux-pane-io-context
            source: |
              msg, err = parse_json(.message)
              .input = msg.message.input
              .output = msg.message.output
              .host = msg.host
              .metadata = msg.message.metadata
              del(.message)

          kafka-linestream-to-elasticsearch:
            type: "remap"
            inputs:
              - kafka-tmux-pane-linestream
            source: |
              msg, err = parse_json(.message)
              .line = msg.message
              .host = msg.host
              .tmux_pane_id = msg.tmux_pane.id
              del(.message)


          tmux-stream-split-line:
            type: "lua"
            version: "2"
            inputs:
              - tmux-pane-bytestream
            hooks:
              process: process
              init: init
            source: |
              function init()
                line = {}
              end
              function process(event, emit)
                ch = event.log.message
                tmux_pane_id = string.gsub(event.log.tmux_pane_id, "[^%0-9]", "")
                event.log.tmux_pane_id = tmux_pane_id
                -- newline
                if ch == "0a" then
                  event.log.message = line[tmux_pane_id]
                  emit(event)
                  line[tmux_pane_id] = ""
                else
                  if line[tmux_pane_id] == nil then
                      line[tmux_pane_id] =  string.format("%c", tonumber(ch, 16))
                    else
                      line[tmux_pane_id] = line[tmux_pane_id] .. string.format("%c", tonumber(ch, 16))
                  end
                end
              end

          tmux-pane-raw-io-context:
            type: "lua"
            version: "2"
            inputs:
              - tmux-pane-bytestream
            hooks:
              process: process
              init: init
            source: |-
              function init()
                line = {}
                data = {}
                input = {}
              end
              function process(event, emit)
                ch = event.log.message
                tmux_pane_id = string.gsub(event.log.tmux_pane_id, " ", "")
                event.log.tmux_pane_id = tmux_pane_id
                --[[
                  FIXME (@metacoma) without this ugly hack, this pipeline will generate
                  empty io-context message like following:
                    {"host":"nixos","message":{"input":"","metadata":{"tmux_pane_id":"%59"}},"source_type":"file_descriptor","timestamp":"2023-01-10T13:46:19.760164430Z","tmux_pane_id":"%59"}
                ]]
                if ch == "20" and string.match(line[tmux_pane_id], ".*@.*") then
                  -- we found a space character and the line matches the prompt regex
                  if (data[tmux_pane_id] ~= nil and event.log.message.input ~= "" and data[tmux_pane_id] ~= {}) then
                    event.log.message = {
                      input = input[tmux_pane_id],
                      output = table.concat(data[tmux_pane_id]),
                      metadata = {
                        tmux_pane_id = tmux_pane_id,
                      }
                    }
                    emit(event)
                  end
                  data[tmux_pane_id] = nil
                  line[tmux_pane_id] = ""
                  input[tmux_pane_id] = ""
                end
                -- newline
                if ch == "0a" then
                  if data[tmux_pane_id] == nil then
                    -- FIXME(@metacoma) multiline input with is not supported
                    input[tmux_pane_id] = line[tmux_pane_id]
                    data[tmux_pane_id] = {}
                  else
                    table.insert(data[tmux_pane_id], line[tmux_pane_id])
                  end
                  line[tmux_pane_id] = ""
                else
                  if line[tmux_pane_id] == nil then
                      line[tmux_pane_id] =  string.format("%c", tonumber(ch, 16))
                    else
                     line[tmux_pane_id] = line[tmux_pane_id] .. string.format("%c", tonumber(ch, 16))
                  end
                end
              end

#                                  _       _
#                                 (_)     | |
#                              ___ _ _ __ | | _____
#                             / __| | '_ \| |/ / __|
#                             \__ \ | | | |   <\__ \
#                             |___/_|_| |_|_|\_\___/
#
#

        sinks:
          kafka-tmux-pane-bytestream:
            type: kafka
            inputs:
              - tmux-pane-bytestream
            bootstrap_servers: "${kafka_cluster_name}-kafka-external-bootstrap.${kafka_k8s_namespace}:${kafka_port}"
            topic: "${kafka_topic_tmux_bytestream}"
            compression: "none"
            encoding:
              codec: json
          console:
            type: console
            inputs:
              # - tmux-stream-split-line
              # - kafka-linestream-to-elasticsearch
              - kafka-tmux-pane-linestream
              - kafka-io-context-to-elasticsearch
            encoding:
              codec: json
          kafka-tmux-pane-raw-linestream:
            type: kafka
            inputs:
              -  tmux-stream-split-line
            bootstrap_servers: "${kafka_cluster_name}-kafka-external-bootstrap.${kafka_k8s_namespace}:${kafka_port}"
            # topic: "${kafka_topic_tmux_linestream}"
            topic: "${kafka_topic_tmux_raw_linestream}" # linestream with shell color codes
            compression: "none"
            encoding:
              codec: json
          opensearch-raw-tmux-lines:
            type: elasticsearch
            inputs:
              - tmux-stream-split-line
            endpoint: https://${opensearch_helm_release}-cluster-master.${opensearch_k8s_namespace}:9200
            api_version: "v7" # https://opensearch.org/faq/
            auth: # TODO (@metacoma) use opensearch credentials from opensearch class
              user: ${opensearch_vector_user}
              password: ${opensearch_vector_password}
              strategy: basic
            tls:
              verify_certificate: false
              verify_hostname: false
            healthcheck:
              enabled: false
            bulk:
              index: "${opensearch_raw_tmux_lines_index}-%F"

          opensearch-raw-tmux-io-context:
            type: elasticsearch
            inputs:
              - tmux-pane-raw-io-context
            endpoint: https://${opensearch_helm_release}-cluster-master.${opensearch_k8s_namespace}:9200
            api_version: "v7" # https://opensearch.org/faq/
            auth: # TODO (@metacoma) use opensearch credentials from opensearch class
              user: ${opensearch_vector_user}
              password: ${opensearch_vector_password}
              strategy: basic
            tls:
              verify_certificate: false
              verify_hostname: false
            healthcheck:
              enabled: false
            bulk:
              index: "${opensearch_raw_tmux_io_context_index}-%F"

          kafka-tmux-pane-raw-io-context:
            type: kafka
            inputs:
              - tmux-pane-raw-io-context
              # - tmux-pane-io-context
            bootstrap_servers: "${kafka_cluster_name}-kafka-external-bootstrap.${kafka_k8s_namespace}:${kafka_port}"
            topic: "${kafka_topic_tmux_raw_io_context}"
            compression: "none"
            encoding:
              codec: json

          opensearch-tmux-io-context:
            type: elasticsearch
            inputs:
              - kafka-io-context-to-elasticsearch
            endpoint: https://${opensearch_helm_release}-cluster-master.${opensearch_k8s_namespace}:9200
            api_version: "v7" # https://opensearch.org/faq/
            auth: # TODO (@metacoma) use opensearch credentials from opensearch class
              user: ${opensearch_vector_user}
              password: ${opensearch_vector_password}
              strategy: basic
            tls:
              verify_certificate: false
              verify_hostname: false
            healthcheck:
              enabled: false
            bulk:
              index: "${opensearch_tmux_io_context_index}-%F"

          opensearch-tmux-pane-linestream:
            type: elasticsearch
            inputs:
              - kafka-linestream-to-elasticsearch
            endpoint: https://${opensearch_helm_release}-cluster-master.${opensearch_k8s_namespace}:9200
            api_version: "v7" # https://opensearch.org/faq/
            auth: # TODO (@metacoma) use opensearch credentials from opensearch class
              user: ${opensearch_vector_user}
              password: ${opensearch_vector_password}
              strategy: basic
            tls:
              verify_certificate: false
              verify_hostname: false
            healthcheck:
              enabled: false
            bulk:
              index: "${opensearch_tmux_lines_index}-%F"

  tmuxinator:
    windows:
      helm:
        panes:
          - cd ${kapitan_root}/files/helm-charts/vector
          - cd ${kapitan_root}/files/helm-charts/vector
      shell:
        panes:
          # tmux list-windows -a -F '#{window_id} #{pane_id}'
          -
            - tmux pipe-pane -IO "perl ${compiled_dir}/pipe-pane2hexstream.pl | VECTOR_UPSTREAM=`minikube ip`:${vector_aggregator_port} TMUX_PANE_ID='$TMUX_PANE' vector -q --config ${compiled_dir}/vector/tmux-bytestream.yaml"
          -
            - vector_logs -f

